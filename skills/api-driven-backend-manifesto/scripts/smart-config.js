#!/usr/bin/env node

/**
 * Smart Configuration Manager
 * 
 * Features:
 * 1. Automatically detect development environment
 * 2. Generate optimized .env configuration
 * 3. Verify database connection
 * 4. Automatically fix common configuration errors
 * 
 * Usage: node scripts/smart-config.js
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const colors = {
    reset: '\x1b[0m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    red: '\x1b[31m',
    cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
    console.log(`${colors[color]}${message}${colors.reset}`);
}

function question(query) {
    return new Promise(resolve => rl.question(query, resolve));
}

// Detect if MySQL is installed
function detectMySQL() {
    try {
        execSync('mysql --version', { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

// Detect if PostgreSQL is installed
function detectPostgres() {
    try {
        execSync('psql --version', { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

// Detect if Redis is installed
function detectRedis() {
    try {
        execSync('redis-cli --version', { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

// Test MySQL connection
function testMySQLConnection(host, port, user, password) {
    try {
        const cmd = password
            ? `mysql -h ${host} -P ${port} -u ${user} -p${password} -e "SELECT 1"`
            : `mysql -h ${host} -P ${port} -u ${user} -e "SELECT 1"`;
        execSync(cmd, { stdio: 'ignore' });
        return true;
    } catch {
        return false;
    }
}

// Test PostgreSQL connection
function testPostgresConnection(host, port, user, password) {
    try {
        const env = { ...process.env, PGPASSWORD: password };
        execSync(`psql -h ${host} -p ${port} -U ${user} -c "SELECT 1"`, { stdio: 'ignore', env });
        return true;
    } catch {
        return false;
    }
}

// Generate .env file
function generateEnvFile(config) {
    let dbSection;
    if (config.dbType === 'postgres') {
        dbSection = `# Database - PostgreSQL (ADBM recommended)
DB_TYPE=postgres
DB_HOST=${config.db.host}
DB_PORT=${config.db.port}
DB_USER=${config.db.user}
DB_PASSWORD=${config.db.password}
DB_NAME=${config.db.database}
DATABASE_URL=postgresql://${config.db.user}:${config.db.password}@${config.db.host}:${config.db.port}/${config.db.database}?schema=public`;
    } else {
        dbSection = `# Database - MySQL
DB_TYPE=mysql
DB_HOST=${config.db.host}
DB_PORT=${config.db.port}
DB_USER=${config.db.user}
DB_PASSWORD=${config.db.password}
DB_NAME=${config.db.database}
DATABASE_URL=mysql://${config.db.user}:${config.db.password}@${config.db.host}:${config.db.port}/${config.db.database}`;
    }

    const envContent = `# Environment Configuration
# Generated by Smart Config Manager at ${new Date().toISOString()}

# Application
NODE_ENV=${config.nodeEnv}
PORT=${config.port}

${dbSection}

# Redis
REDIS_HOST=${config.redis.host}
REDIS_PORT=${config.redis.port}
REDIS_PASSWORD=${config.redis.password}
REDIS_URL=redis://${config.redis.password ? ':' + config.redis.password + '@' : ''}${config.redis.host}:${config.redis.port}

# JWT
JWT_SECRET=${config.jwtSecret}
JWT_EXPIRES_IN=15m
JWT_REFRESH_EXPIRES_IN=7d

# CORS
CORS_ORIGIN=${config.corsOrigin}

# Rate Limiting
RATE_LIMIT_MAX=100
RATE_LIMIT_WINDOW_MS=60000
`;

    fs.writeFileSync(path.join(process.cwd(), '.env'), envContent);
    log('‚úÖ .env file generated successfully!', 'green');
}

async function runConfigWizard() {
    log('\nüöÄ Smart Configuration Manager (ADBM-Aligned)', 'cyan');
    log('‚îÅ'.repeat(50), 'cyan');

    // Detect environment
    log('\nüìã Detecting environment...', 'blue');
    const hasPostgres = detectPostgres();
    const hasMysql = detectMySQL();
    const hasRedis = detectRedis();

    log(`  PostgreSQL: ${hasPostgres ? '‚úÖ Installed' : '‚ùå Not found'}`, hasPostgres ? 'green' : 'yellow');
    log(`  MySQL:      ${hasMysql ? '‚úÖ Installed' : '‚ùå Not found'}`, hasMysql ? 'green' : 'yellow');
    log(`  Redis:      ${hasRedis ? '‚úÖ Installed' : '‚ùå Not found'}`, hasRedis ? 'green' : 'yellow');

    // DB Type Selection
    log('\nüóÑÔ∏è  Database Selection', 'blue');
    log('  ADBM recommends PostgreSQL for all Growth/Enterprise projects.', 'cyan');
    const dbChoice = await question('  Select database (1: PostgreSQL [recommended], 2: MySQL): ');
    const usePostgres = dbChoice.trim() !== '2';

    const config = {
        nodeEnv: 'development',
        port: 4000,
        dbType: usePostgres ? 'postgres' : 'mysql',
        db: {},
        redis: {},
        corsOrigin: 'http://localhost:3000'
    };

    if (usePostgres && !hasPostgres) {
        log('\n‚ö†Ô∏è  PostgreSQL not detected. Install from https://www.postgresql.org/download/', 'yellow');
    }
    if (!usePostgres && !hasMysql) {
        log('\n‚ö†Ô∏è  MySQL not detected. Install from https://dev.mysql.com/downloads/mysql/', 'yellow');
    }

    // Database Configuration
    const defaultPort = usePostgres ? '5432' : '3306';
    const defaultUser = usePostgres ? 'postgres' : 'root';
    log(`\nüóÑÔ∏è  ${usePostgres ? 'PostgreSQL' : 'MySQL'} Configuration`, 'blue');
    config.db.host = await question(`  Host [localhost]: `) || 'localhost';
    config.db.port = await question(`  Port [${defaultPort}]: `) || defaultPort;
    config.db.user = await question(`  User [${defaultUser}]: `) || defaultUser;
    config.db.password = await question(`  Password: `);
    config.db.database = await question(`  Database name [app_db]: `) || 'app_db';

    // Test database connection
    log('\nüîç Testing database connection...', 'blue');
    const dbConnected = usePostgres
        ? testPostgresConnection(config.db.host, config.db.port, config.db.user, config.db.password)
        : testMySQLConnection(config.db.host, config.db.port, config.db.user, config.db.password);

    if (dbConnected) {
        log('  ‚úÖ Database connection successful!', 'green');
    } else {
        log('  ‚ùå Database connection failed!', 'red');
        const retry = await question('  Retry configuration? (y/n): ');
        if (retry.toLowerCase() === 'y') {
            rl.close();
            return runConfigWizard();
        }
    }

    // Redis Configuration
    log('\nüì¶ Redis Configuration', 'blue');
    if (hasRedis) {
        config.redis.host = await question(`  Host [localhost]: `) || 'localhost';
        config.redis.port = await question(`  Port [6379]: `) || '6379';
        config.redis.password = await question(`  Password (leave empty if none): `) || '';
    } else {
        log('  ‚ö†Ô∏è  Redis not detected, using defaults', 'yellow');
        config.redis.host = 'localhost';
        config.redis.port = '6379';
        config.redis.password = '';
    }

    // JWT Secret
    log('\nüîê Security Configuration', 'blue');
    const useRandomSecret = await question('  Generate random JWT secret? (Y/n): ');
    if (useRandomSecret.toLowerCase() !== 'n') {
        config.jwtSecret = require('crypto').randomBytes(32).toString('hex');
        log('  ‚úÖ Generated secure JWT secret', 'green');
    } else {
        config.jwtSecret = await question('  Enter JWT secret: ');
    }

    // Generate configuration file
    log('\nüìù Generating configuration file...', 'blue');
    generateEnvFile(config);

    // Create database if it doesn't exist
    if (dbConnected) {
        log('\nüóÑÔ∏è  Creating database if not exists...', 'blue');
        try {
            const createDbCmd = config.db.password
                ? `mysql -h ${config.db.host} -P ${config.db.port} -u ${config.db.user} -p${config.db.password} -e "CREATE DATABASE IF NOT EXISTS ${config.db.database} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"`
                : `mysql -h ${config.db.host} -P ${config.db.port} -u ${config.db.user} -e "CREATE DATABASE IF NOT EXISTS ${config.db.database} CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"`;

            execSync(createDbCmd, { stdio: 'ignore' });
            log('  ‚úÖ Database ready', 'green');
        } catch (error) {
            log('  ‚ö†Ô∏è  Could not create database automatically', 'yellow');
            log('  Please create it manually: CREATE DATABASE ' + config.db.database, 'yellow');
        }
    }

    // Summary
    log('\n' + '‚îÅ'.repeat(50), 'cyan');
    log('‚úÖ Configuration Complete!', 'green');
    log('\nüìã Next Steps:', 'blue');
    log('  1. Install dependencies: npm install', 'cyan');
    log('  2. Initialize database: npm run db:init', 'cyan');
    log('  3. Start development: npm run dev', 'cyan');

    rl.close();
}

runConfigWizard().catch(error => {
    log('\n‚ùå Error: ' + error.message, 'red');
    rl.close();
    process.exit(1);
});
